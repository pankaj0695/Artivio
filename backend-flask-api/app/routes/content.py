"""Content suggestion endpoints (title, tagline, description, tags, SEO)."""
from __future__ import annotations

from flask import Blueprint, jsonify, request

from ..services.vertex_text import VertexTextService

content_bp = Blueprint("content", __name__)
text_service = VertexTextService()


@content_bp.post("/title")
def suggest_title():
    """Return only generated title."""
    data = request.get_json(silent=True) or {}
    product_name = data.get("productTitle", "").strip()
    category = data.get("category", "").strip()
    if not product_name:
        return jsonify({"error": "BadRequest", "message": "productTitle is required"}), 400
    try:
        keywords = text_service.generate_keywords(product_name, category)
        title = text_service.generate_title(product_name, keywords)
        return jsonify({"title": title})
    except Exception as e:
        return jsonify({"error": "TitleGenerationError", "message": str(e)[:200]}), 500


@content_bp.post("/tagline")
def suggest_tagline():
    """Return only generated tagline (fallback if blocked)."""
    data = request.get_json(silent=True) or {}
    product_name = data.get("productTitle", "").strip()
    keywords = ", ".join(data.get("keywords", [])).strip()
    if not product_name:
        return jsonify({"error": "BadRequest", "message": "productTitle is required"}), 400
    try:
        tagline = text_service.generate_tagline(product_name, keywords)
        if not tagline:
            raise ValueError("Empty tagline returned")
        return jsonify({"tagline": tagline})
    except ValueError:
        fallback = f"{product_name} artisan crafted"
        return jsonify({"tagline": fallback}), 200
    except Exception as e:
        return jsonify({"error": "TaglineGenerationError", "message": str(e)[:200]}), 500


@content_bp.post("/description")
def suggest_description():
    """Return only generated description."""
    data = request.get_json(silent=True) or {}
    product_name = data.get("productTitle", "").strip()
    category = data.get("category", "").strip()
    if not product_name:
        return jsonify({"error": "BadRequest", "message": "productTitle is required"}), 400
    try:
        keywords = text_service.generate_keywords(product_name, category)
        description = text_service.generate_description(product_name, keywords)
        return jsonify({"description": description})
    except Exception as e:
        return jsonify({"error": "DescriptionGenerationError", "message": str(e)[:200]}), 500


@content_bp.post("/tags")
def suggest_tags():
    """Return only generated tags array."""
    data = request.get_json(silent=True) or {}
    product_name = data.get("productTitle", "").strip()
    category = data.get("category", "").strip()
    if not product_name:
        return jsonify({"error": "BadRequest", "message": "productTitle is required"}), 400
    try:
        keywords = text_service.generate_keywords(product_name, category)
        tags = [t.strip().lower() for t in (keywords.split(",") if keywords else []) if t.strip()]
        dedup = []
        for t in tags:
            if t not in dedup:
                dedup.append(t)
        return jsonify({"tags": dedup[:15]})
    except Exception as e:
        return jsonify({"error": "TagsGenerationError", "message": str(e)[:200]}), 500


@content_bp.post("/prompt")
def generate_from_prompt():
    """Return raw text generated by Gemini for an arbitrary prompt.

    Body (JSON) or querystring:
      - prompt: string (required)
      - maxTokens: int (optional, default 256)
      - temperature: float (optional, default 0.2)
    """
    data = request.get_json(silent=True) or {}
    prompt = (data.get("prompt") or request.args.get("prompt") or "").strip()
    if not prompt:
        return jsonify({"error": "BadRequest", "message": "prompt is required"}), 400

    # Parse optional params
    try:
        max_tokens_raw = data.get("maxTokens") if "maxTokens" in data else request.args.get("maxTokens")
        temperature_raw = data.get("temperature") if "temperature" in data else request.args.get("temperature")
        max_tokens = int(max_tokens_raw) if max_tokens_raw is not None else 256
        temperature = float(temperature_raw) if temperature_raw is not None else 0.2
    except (TypeError, ValueError):
        return jsonify({
            "error": "BadRequest",
            "message": "maxTokens must be an integer and temperature must be a float",
        }), 400

    try:
        result = text_service._call_model(prompt, max_output_tokens=max_tokens, temperature=temperature)
        # If model returned an error and no text, bubble it up
        if not result.get("text") and result.get("error"):
            return jsonify({
                "error": "ModelError",
                "message": str(result.get("error"))[:200],
            }), 502
        return jsonify({"text": result.get("text", "")})
    except Exception as e:  # noqa: BLE001
        return jsonify({"error": "PromptGenerationError", "message": str(e)[:200]}), 500
